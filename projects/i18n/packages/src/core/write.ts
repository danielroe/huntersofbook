import { copyFileSync, existsSync, mkdir, mkdirSync, readFileSync, rmSync, rmdirSync, writeFileSync } from 'node:fs'

import { basename, dirname, join, resolve } from 'pathe'
import consola from 'consola'
import Debug from 'debug'

import { merge } from '@huntersofbook/schob'
import { globbySync } from 'globby'
import type { Context } from './context'
import { sortObject } from './utils'

const debug = Debug('unplugin-i18n-watch:write')

const schemaMergeSave = async (ctx: {
  exportFile: any
  templateFile?: string | undefined
}) => {
  let template: any = {}
  existsSync(ctx.exportFile)

  if (ctx.templateFile) {
    try {
      const data = readFileSync(ctx.templateFile, 'utf8')
      template = JSON.parse(data)
    }
    catch (error) {
      consola.error('this file is not valid please your schema', ctx.templateFile)
      return
    }
  }

  let exportFileString: string | undefined

  try {
    exportFileString = readFileSync(ctx.exportFile, 'utf8')
  }
  catch (error) {
    writeFileSync(ctx.exportFile, template)
  }

  if (!existsSync(ctx.exportFile) || Object.keys(template).length === 0 || !exportFileString) {
    writeFileSync(ctx.exportFile, JSON.stringify(template, null, 2), { mode: 0o777 })
    return
  }

  const exportJSONData = JSON.parse(exportFileString)

  if (template === exportJSONData)
    return

  if (Object.keys(exportJSONData).length > 0) {
    const _merge = merge({ schema: template, newData: exportJSONData })
    try {
      const sortedObject = sortObject(_merge)
      try {
        writeFileSync(ctx.exportFile, JSON.stringify(sortedObject, null, 2))
      }
      catch (error) {
        consola.error(error)
      }
    }
    catch (error) {
      consola.error(error)
    }
  }
  else {
    if (!existsSync(dirname(ctx.exportFile))) {
      mkdir(ctx.exportFile, { recursive: true }, (err) => {
        if (err)
          consola.error(err)
      })
    }

    try {
      writeFileSync(ctx.exportFile, JSON.stringify(template, null, 2))
      consola.success(`JSON file ${basename(ctx.exportFile)} is created`)
    }
    catch (error) {
      consola.error(error, ctx.exportFile)
    }
  }
}

const directoriesMergeSave = async (ctx: {
  exportFile: any
  directoriesJSONString: string
  directoryTemplate: string
  directoryAsNamespace?: boolean
}) => {
  existsSync(ctx.exportFile)

  const template = JSON.parse(ctx.directoryTemplate)
  const newData = JSON.parse(ctx.directoriesJSONString)

  if (Object.keys(newData).length > 0) {
    const _merge = merge({ schema: template, newData })
    try {
      const sortedObject = sortObject(_merge)
      const jsonComment = JSON.stringify({
        0: 'This file is automatically generated. Do not edit this file manually.',
      }, null, 2)

      try {
        const mergeObjectandComment = Object.assign({}, sortedObject, JSON.parse(jsonComment))
        writeFileSync(ctx.exportFile, JSON.stringify(mergeObjectandComment, null, 2))
      }
      catch (error) {
        consola.error(error)
      }
    }
    catch (error) {
      consola.error(error)
    }
  }
  else {
    if (!existsSync(dirname(ctx.exportFile))) {
      mkdir(ctx.exportFile, { recursive: true }, (err) => {
        if (err)
          consola.error(err)
      })
    }

    if (ctx.directoriesJSONString) {
      const obj = JSON.parse(ctx.directoriesJSONString)
      const _merge = merge({ schema: template, newData: obj })

      try {
        writeFileSync(ctx.exportFile, JSON.stringify(_merge, null, 2))
        consola.success(`JSON file ${basename(ctx.exportFile)} is created`)
      }
      catch (error) {
        consola.error(error, 'aa')
      }
    }
    else {
      try {
        writeFileSync(ctx.exportFile, JSON.stringify(template, null, 2))
        consola.success(`JSON file ${basename(ctx.exportFile)} is created`)
      }
      catch (error) {
        consola.error(error, ctx.exportFile)
      }
    }
  }
}

export async function writeI18nLanguageFile(ctx: Context, filepath?: string) {
  const templateDir = resolve(ctx.root, ctx.options.templateDir)
  const exportDir = resolve(ctx.root, ctx.options.exportDir)
  // check is directory
  if (!existsSync(templateDir))
    mkdirSync(templateDir)

  if (!existsSync(exportDir))
    mkdirSync(exportDir)

  const languages = ctx.options.languages
  debug('languages', languages)

  // ['/home/productdevbook/Documents/github/opensource/huntersofbook/projects/i18n/playground/language/tr.json']
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const exportLanguageFiles = languages.map((language) => {
    return join(exportDir, `${language}.json`)
  })

  // ['  '/home/productdevbook/Documents/github/opensource/huntersofbook/projects/i18n/playground/language/tr']
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const exportLanguageDir = languages.map((language) => {
    return join(exportDir, language)
  })

  // check is directory
  let tempDirectories: string[] | undefined
  try {
    tempDirectories = globbySync(join(templateDir, '/**/*'), { onlyDirectories: true, cwd: ctx.root })
  }
  catch (error) {

  }

  let checkFile: string[] | undefined

  try {
    checkFile = globbySync(join(templateDir, '/*'), { onlyFiles: true, cwd: ctx.root, deep: 0 })
  }
  catch (error) {

  }

  const existDirectory = tempDirectories?.length && tempDirectories.length > 0
  const onlyFile = checkFile?.length && checkFile.length > 0

  const directoryAsNamespace = !!((ctx.options.directoryAsNamespace && existDirectory))

  if (existDirectory && onlyFile) {
    consola.error('both file and language file cannot be used at the same time. Please use only one of them ["xxx/xx.json", "yyy/vvv.json"] or "schema.json"')
  }
  else {
    if (checkFile && checkFile?.length > 1) {
      consola.error('only one file used. `schema.json`')
      return
    }

    // Check export file and director names
    const exportDirectoryNames = globbySync(join(exportDir, '/*'), { onlyDirectories: true, cwd: ctx.root, deep: 0 })
    const exportFileNames = globbySync(join(exportDir, '/*.json'), { onlyFiles: true, cwd: ctx.root, deep: 0 })

    // ['tr', 'en', 'de']
    languages.forEach((lang) => {
      if (existDirectory) {
        if (!exportDirectoryNames.includes(join(exportDir, `/${lang}`)))
          mkdirSync(join(exportDir, `/${lang}`), { recursive: true })
      }

      if (!exportFileNames.includes(join(exportDir, `/${lang}.json`)))
        writeFileSync(join(exportDir, `/${lang}.json`), '{}')
    })

    const clean = () => {
      if (exportDirectoryNames.length > 0) {
        exportDirectoryNames.forEach((res) => {
          if (!languages.includes(basename(res)))
            rmdirSync(res, { recursive: true })
        })
      }

      exportFileNames.forEach((res) => {
        if (!languages.includes(basename(res, '.json')))
          rmSync(res)
      })
    }
    clean()

    /*
    * If the file is in a directory
    */

    if (existDirectory) {
      debug('directory')
      /**
       * templateFiles example export
       * @example [ '.i18n/xx/xxx.json', '.i18n/xx/yyy.json', '.i18n/xx/zzz.json' ]
       */
      const templateFiles = globbySync(join(templateDir, '/**/*'), { onlyFiles: true, cwd: ctx.root })

      /**
     * templateFiles example export
     * @example [ '.i18n/xx', '.i18n/yy', '.i18n/zz' ]
     */
      const templateDirs = globbySync(join(templateDir, '/**/*'), { onlyDirectories: true, cwd: ctx.root })

      // template folder in files and directories in export folder check and remove
      function clean() {
        // Check export file and director names
        const _exportDirectoryNames = globbySync(join(exportDir, '/**/*'), { onlyDirectories: true, cwd: ctx.root, ignore: languages.map(res => `**/*/${res}`) })
        const _exportFileNames = globbySync(join(exportDir, '/**/*.json'), { onlyFiles: true, cwd: ctx.root, ignore: languages.map(res => `**/*/${res}.json`) })

        languages.forEach((lang) => {
          _exportFileNames.forEach((res) => {
            const base = res.split(`${ctx.options.exportDir}/${lang}`)[1]
            if (base) {
              const changeExportBase = join(templateDir, base)

              if (!templateFiles.includes(changeExportBase))
                rmSync(res)
            }
          })

          _exportDirectoryNames.forEach((res) => {
            const base = res.split(`${ctx.options.exportDir}/${lang}`)[1]
            if (base) {
              const changeExportBase = join(templateDir, base)
              if (!templateDirs.includes(changeExportBase))
                rmdirSync(res)
            }
          })
        })
      }
      clean()

      // etc: en, tr, de
      /**
       * Directory names in export folder
      */
      languages.forEach((lang) => {
        const _exportDirectories = globbySync(join(ctx.options.exportDir, lang, '/**/*'), { onlyDirectories: true, cwd: ctx.root })

        templateDirs.forEach((res) => {
          const base = res.split(ctx.options.templateDir)[1]
          const changeExportBase = join(exportDir, lang, base)
          // create templates directories mkdir
          if (!_exportDirectories.includes(changeExportBase)) {
            if (!existsSync(changeExportBase))
              mkdirSync(changeExportBase, { recursive: true })
          }
        })

        // etc: en/buttons/filename.json
        const fileNames = globbySync(join(exportDir, lang, '/**/*'), { onlyFiles: true, cwd: ctx.root, ignore: languages.map(res => `**/*/${res}.json`) })
        // etc: ["/buttons/filename.json", "/buttons/filename.json"]
        templateFiles.forEach((tt) => {
          // etc: /buttons/filename.json
          const tempDir = tt.split(ctx.options.templateDir)[1]
          // etc: en/buttons/filename.json
          const exportWithTemplate = join(exportDir, lang, tempDir)
          if (!fileNames.includes(exportWithTemplate)) {
            writeFileSync(exportWithTemplate, readFileSync(tt, { encoding: 'utf-8' }))
          }
          else {
            schemaMergeSave({
              exportFile: exportWithTemplate,
              templateFile: tt,
            })
          }
        })
      })

      /**
       * Language save files ['language/en/** /*.json', 'language/** /*.json'] -> ['language/en.json', 'language/tr.json']
      */
      const templateMergeOjb = {}
      templateFiles.forEach((file) => {
        const data = JSON.parse(readFileSync(file, 'utf8'))
        if (directoryAsNamespace) {
          const folderName = basename(dirname(file))
          Object.assign(templateMergeOjb, {
            [folderName]: data,
          })
        }
        else {
          Object.assign(templateMergeOjb, data)
        }
      })

      languages.forEach((lang) => {
        const files = globbySync(join(exportDir, lang, '/**/*.json'), { onlyFiles: true, cwd: ctx.root })

        try {
          const obj = {}
          files.forEach((file) => {
            const data = JSON.parse(readFileSync(file, 'utf8'))
            /**
            *  If the file is in a directory, the directory name is used as a namespace
           */
            if (directoryAsNamespace) {
              const folderName = basename(dirname(file))
              Object.assign(obj, {
                [folderName]: data,
              })
            }
            else {
              Object.assign(obj, data)
            }
          })

          // isExist directory

          if (!existsSync(join(exportDir, lang)))
            mkdirSync(join(exportDir, lang), { recursive: true })

          const exportFile = join(exportDir, `${lang}.json`)
          debug('Merge file language', exportFile)

          directoriesMergeSave({
            exportFile,
            directoriesJSONString: JSON.stringify(obj, null, 2),
            directoryTemplate: JSON.stringify(templateMergeOjb, null, 2),
            directoryAsNamespace,
          })

          consola.success(`${`${`${basename(ctx.options.exportDir)}/${lang}`}.json`} updated`)
        }
        catch (error) {
          consola.error('JSON file is not valid please your schema dir')
        }
      })
    }
    /*
    * If the only schema.json file in the template directory
    */
    else {
      /*
      * One file `schema.json` in template directory
      */
      // Check old files and remove
      const directoryExport = globbySync(join(exportDir, '**/*'), { onlyDirectories: true })
      if (directoryExport.length > 0) {
        // remove directory
        directoryExport.forEach((dir) => {
          rmdirSync(dir, { recursive: true })
        })
      }

      if (filepath) {
        const templateFile = resolve(filepath)

        if (!templateFile.includes('schema.json')) {
          consola.error('schema.json file not found')
          return
        }

        const checkLanguges = globbySync(join(exportDir, '*.json'), { onlyFiles: true })

        if (checkLanguges.length > 0) {
          languages.forEach((lang) => {
            const exportFile = join(exportDir, `${lang}.json`)
            debug('exportFile', exportFile)

            schemaMergeSave({
              exportFile,
              templateFile,
            })
          })
        }
        else {
          languages.forEach((lang) => {
            copyFileSync(templateFile, join(exportDir, `${lang}.json`))
          })
        }
      }
      else {
        const files = globbySync(join(templateDir, '*.json'), { onlyFiles: true, cwd: ctx.root, deep: 0 })

        if (files.length > 0) {
          let find: string | undefined

          files.forEach((file) => {
            const isSchema = file.includes('schema.json')
            if (isSchema)
              find = file
            else
              consola.error('schema.json file not found')
          })

          if (find) {
            languages.forEach((lang) => {
              const exportFile = join(exportDir, `${lang}.json`)
              debug('exportFile', exportFile)
              schemaMergeSave({
                exportFile,
                templateFile: find,
              })
            })
          }
        }
      }
    }
  }
}
